#pragma once

#include "json.h"

namespace json {

class Builder {
public:
    // Метод Build завершает построение JSON-объекта и возвращает готовый Node
    // Если объект ещё не готов (например, сразу после конструктора, или остались
    // незакрытые словари/массивы), бросаем std::logic_error
    Node Build();

    // Добавляет строковый ключ в словарь.
    // Следующий вызов обязательно должен быть Value(...) или StartDict/StartArray
    Builder& Key(std::string key);

    // Добавляет простое значение (число, строку, bool, null).
    // Может быть вызван:
    // - сразу после конструктора (задаёт весь объект целиком);
    // - после Key (задаёт значение по ключу в словаре);
    // - после Value/StartDict/StartArray внутри массива (добавляет очередной элемент массива).
    Builder& Value(Node::Value value);

    // Начинает словарь ({}).
    // Логика та же, что и для Value, только вместо примитивного значения
    // мы добавляем/определяем словарь.
    Builder& StartDict();

    // Завершает последний начатый словарь.
    // Если никакой словарь сейчас не открыт — бросаем std::logic_error.
    Builder& EndDict();

    // Начинает массив ([]).
    // Логика аналогична словарю: может вызываться там же, где Value(...).
    Builder& StartArray();

    // Завершает последний начатый массив.
    // Если никакой массив сейчас не открыт — бросаем std::logic_error.
    Builder& EndArray();

private:
    // Узел-корень (итоговый объект)
    Node root_;

    // Стек "текущих" узлов, в которые мы добавляем новые значения.
    // Если на вершине лежит Dict, то следующий Key/Value
    // идёт в этот словарь; если Array — то следующий Value/StartDict/StartArray
    // добавляется в этот массив.
    std::vector<Node*> nodes_stack_;

    // Последний считанный ключ при построении словаря
    // (вспомогательное поле, чтобы связать Key(...) c последующей Value(...))
    std::string current_key_;
    
    bool key_in_progress_ = false;  // Флаг для отслеживания состояния ключа

    // Флаг, показывающий, что Build уже вызывался и дальнейшее редактирование невозможно
    bool is_build_finished_ = false;

    // Вспомогательные методы
    bool IsInArray() const;
    bool IsInDict() const;
    // Проверить, можем ли мы сейчас вызвать Value/StartDict/StartArray
    bool CanAddValue() const;
};

} // namespace json